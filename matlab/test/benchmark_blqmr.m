function benchmark_blqmr()
%BENCHMARK_BLQMR Compare BLQMR solver with MATLAB's mldivide and QMR
%
%   Tests both real and complex symmetric sparse FEM matrices using
%   tetrahedral meshes generated by meshgrid6 with realistic sparse RHS

fprintf('=====================================================================================================\n');
fprintf('BLQMR BENCHMARK: Block QMR vs QMR vs MATLAB mldivide (backslash)\n');
fprintf('=====================================================================================================\n\n');

% Test configuration
grid_sizes = [5, 8, 10, 15, 20, 25, 30, 40, 50];  % grid points per dimension
nrhs = 4;           % Number of right-hand sides (block size)
tol = 1e-8;         % Convergence tolerance
maxiter = 1000;     % Maximum iterations
n_runs = 3;         % Runs per test (report median)

fprintf('Configuration:\n');
fprintf('  Grid sizes: %s (nodes ~ m^3, elems ~ 6*(m-1)^3)\n', mat2str(grid_sizes));
fprintf('  Block size (nrhs): %d\n', nrhs);
fprintf('  RHS: Sparse surface sources (sum=1, 4-8 nonzeros each)\n');
fprintf('  Tolerance: %.0e\n', tol);
fprintf('  Max iterations: %d\n', maxiter);
fprintf('  Runs per test: %d (median reported)\n\n', n_runs);

% Run benchmarks
fprintf('Testing REAL symmetric FEM matrices (tetrahedral mesh)...\n');
fprintf('-----------------------------------------------------------------------------------------------------\n');
real_results = run_benchmark(grid_sizes, 'real', nrhs, tol, maxiter, n_runs);
print_results(real_results, 'REAL', nrhs);

fprintf('\nTesting COMPLEX SYMMETRIC FEM matrices (A = A^T, not Hermitian)...\n');
fprintf('-----------------------------------------------------------------------------------------------------\n');
complex_results = run_benchmark(grid_sizes, 'complex', nrhs, tol, maxiter, n_runs);
print_results(complex_results, 'COMPLEX', nrhs);

% Summary
print_summary(real_results, complex_results);
end

function results = run_benchmark(grid_sizes, matrix_type, nrhs, tol, maxiter, n_runs)
%RUN_BENCHMARK Execute benchmarks for all grid sizes

num_tests = length(grid_sizes);
results = struct(...
    'grid', cell(1, num_tests), ...
    'n', cell(1, num_tests), ...
    'nelem', cell(1, num_tests), ...
    'nnz', cell(1, num_tests), ...
    't_mldivide', cell(1, num_tests), ...
    'res_mldivide', cell(1, num_tests), ...
    't_qmr', cell(1, num_tests), ...
    'res_qmr', cell(1, num_tests), ...
    'iter_qmr', cell(1, num_tests), ...
    'flag_qmr', cell(1, num_tests), ...
    't_blqmr', cell(1, num_tests), ...
    'res_blqmr', cell(1, num_tests), ...
    'iter_blqmr', cell(1, num_tests), ...
    'flag_blqmr', cell(1, num_tests));

for idx = 1:num_tests
    m = grid_sizes(idx);
    fprintf('  Testing grid %dx%dx%d ...', m, m, m);
    
    % Generate tetrahedral mesh using meshgrid6
    [node, elem] = meshgrid6(0:m-1, 0:m-1, 0:m-1);
    n = size(node, 1);
    nelem = size(elem, 1);
    
    % Assemble FEM stiffness matrix
    [A, nnz_count] = assemble_fem_matrix(node, elem, matrix_type);
    
    % Create RHS using barycentric coordinates (like Redbird)
    B = create_point_sources(node, elem, nrhs, matrix_type);
    
    fprintf(' (n=%d, elem=%d) ...', n, nelem);
    
    % ===== Benchmark mldivide =====
    times_mldiv = zeros(n_runs, 1);
    x_mldiv = [];
    for r = 1:n_runs
        tic;
        x_mldiv = A \ B;
        times_mldiv(r) = toc;
    end
    t_mldiv = median(times_mldiv);
    res_mldiv = compute_max_residual(A, x_mldiv, B);
    
    % ===== Benchmark QMR (MATLAB built-in, solve each RHS separately) =====
    times_qmr = zeros(n_runs, 1);
    flags_qmr = zeros(n_runs, 1);
    iters_qmr = zeros(n_runs, 1);
    x_qmr = zeros(n, nrhs);
    if strcmp(matrix_type, 'complex')
        x_qmr = complex(x_qmr);
    end
    
    for r = 1:n_runs
        total_iter = 0;
        max_flag = 0;
        tic;
        for k = 1:nrhs
            [x_qmr(:,k), flag_k, ~, iter_k] = qmr(A, B(:,k), tol, maxiter);
            total_iter = total_iter + iter_k;
            max_flag = max(max_flag, flag_k);
        end
        times_qmr(r) = toc;
        flags_qmr(r) = max_flag;
        iters_qmr(r) = total_iter;
    end
    
    [~, med_idx_qmr] = min(abs(times_qmr - median(times_qmr)));
    t_qmr = times_qmr(med_idx_qmr);
    flag_qmr = flags_qmr(med_idx_qmr);
    iter_qmr = iters_qmr(med_idx_qmr);
    
    if flag_qmr <= 1 && ~any(isnan(x_qmr(:)))
        res_qmr = compute_max_residual(A, x_qmr, B);
    else
        res_qmr = Inf;
    end
    
    % ===== Benchmark BLQMR (no preconditioner) =====
    times_blqmr = zeros(n_runs, 1);
    flags_blqmr = zeros(n_runs, 1);
    iters_blqmr = zeros(n_runs, 1);
    x_blqmr = [];
    
    for r = 1:n_runs
        tic;
        [x_blqmr, flag, ~, niter] = blqmr(A, B, tol, maxiter);
        times_blqmr(r) = toc;
        flags_blqmr(r) = flag;
        iters_blqmr(r) = niter;
    end
    
    [~, med_idx] = min(abs(times_blqmr - median(times_blqmr)));
    t_blqmr = times_blqmr(med_idx);
    flag_blqmr = flags_blqmr(med_idx);
    iter_blqmr = iters_blqmr(med_idx);
    
    if flag_blqmr <= 1 && ~isempty(x_blqmr) && ~any(isnan(x_blqmr(:)))
        res_blqmr = compute_max_residual(A, x_blqmr, B);
    else
        res_blqmr = Inf;
    end
    
    % Store results
    results(idx).grid = m;
    results(idx).n = n;
    results(idx).nelem = nelem;
    results(idx).nnz = nnz_count;
    results(idx).t_mldivide = t_mldiv;
    results(idx).res_mldivide = res_mldiv;
    results(idx).t_qmr = t_qmr;
    results(idx).res_qmr = res_qmr;
    results(idx).iter_qmr = iter_qmr;
    results(idx).flag_qmr = flag_qmr;
    results(idx).t_blqmr = t_blqmr;
    results(idx).res_blqmr = res_blqmr;
    results(idx).iter_blqmr = iter_blqmr;
    results(idx).flag_blqmr = flag_blqmr;
    
    fprintf(' done (nnz=%d)\n', nnz_count);
end
end

function [A, nnz_count] = assemble_fem_matrix(node, elem, matrix_type)
%ASSEMBLE_FEM_MATRIX Assemble FEM stiffness matrix for Poisson equation

n = size(node, 1);

% Preallocate triplets (each tet contributes 4x4 = 16 entries)
est_nnz = 16 * size(elem, 1);
II = zeros(est_nnz, 1);
JJ = zeros(est_nnz, 1);
if strcmp(matrix_type, 'complex')
    VV = zeros(est_nnz, 1, 'like', 1i);
else
    VV = zeros(est_nnz, 1);
end

count = 0;

for e = 1:size(elem, 1)
    nodes_e = elem(e, :);
    coords = node(nodes_e, :);
    
    d1 = coords(2,:) - coords(1,:);
    d2 = coords(3,:) - coords(1,:);
    d3 = coords(4,:) - coords(1,:);
    
    J = [d1; d2; d3]';
    detJ = det(J);
    vol = abs(detJ) / 6;
    
    if vol < 1e-15
        continue;
    end
    
    invJ = inv(J);
    grad_ref = [-1 -1 -1; 1 0 0; 0 1 0; 0 0 1]';
    grad_N = invJ' * grad_ref;
    
    Ke = vol * (grad_N' * grad_N);
    Me = vol / 20 * (ones(4) + eye(4));
    
    if strcmp(matrix_type, 'complex')
        Ke = Ke + 0.1i * Me;
    end
    
    for i = 1:4
        for j = 1:4
            count = count + 1;
            II(count) = nodes_e(i);
            JJ(count) = nodes_e(j);
            VV(count) = Ke(i, j);
        end
    end
end

II = II(1:count);
JJ = JJ(1:count);
VV = VV(1:count);

A = sparse(II, JJ, VV, n, n);
A = (A + A.') / 2;

avg_diag = mean(abs(diag(A)));
A = A + 0.01 * avg_diag * speye(n);

nnz_count = nnz(A);
end

function B = create_point_sources(node, elem, nrhs, matrix_type)
%CREATE_POINT_SOURCES Create RHS using barycentric coordinates

n = size(node, 1);
B = zeros(n, nrhs);

xmin = min(node(:,1)); xmax = max(node(:,1));
ymin = min(node(:,2)); ymax = max(node(:,2));
zmin = min(node(:,3)); zmax = max(node(:,3));

rng(42);
src_pos = zeros(nrhs, 3);
for k = 1:nrhs
    fx = 0.25 + 0.5 * mod(k-1, 2);
    fy = 0.25 + 0.5 * floor((k-1)/2);
    fz = 0.4 + 0.1 * k / nrhs;
    
    src_pos(k, :) = [xmin + fx*(xmax-xmin), ...
                     ymin + fy*(ymax-ymin), ...
                     zmin + fz*(zmax-zmin)];
end

[elem_idx, bary] = tsearchn(node, elem, src_pos);

for k = 1:nrhs
    if ~isnan(elem_idx(k))
        nodes_k = elem(elem_idx(k), :);
        B(nodes_k, k) = bary(k, :)';
    else
        [~, nearest] = min(sum((node - src_pos(k,:)).^2, 2));
        B(nearest, k) = 1;
    end
end

if strcmp(matrix_type, 'complex')
    B = complex(B, 0);
end
end

function res = compute_max_residual(A, X, B)
%COMPUTE_MAX_RESIDUAL Compute max relative residual across all RHS columns
nrhs = size(B, 2);
res = 0;
for i = 1:nrhs
    bnorm = norm(B(:,i));
    if bnorm > 0
        ri = norm(A*X(:,i) - B(:,i)) / bnorm;
        res = max(res, ri);
    end
end
end

function str = format_time(t)
if t < 1
    str = sprintf('%.1fms', t * 1000);
else
    str = sprintf('%.2fs', t);
end
end

function str = format_speedup(ratio)
if ratio >= 1
    str = sprintf('%.2fx', ratio);
else
    str = sprintf('%.2fx slw', 1/ratio);
end
end

function print_results(results, matrix_type, nrhs)
%PRINT_RESULTS Display benchmark results in table format

fprintf('\n');
fprintf('RESULTS - %s FEM MATRICES (tetrahedral mesh from meshgrid6)\n', matrix_type);
fprintf('=====================================================================================================\n');
fprintf('Flags: 0=converged, 1=maxiter, 2=precond fail, 3=stagnated\n');
fprintf('QMR iterations = total across %d RHS; BLQMR iterations = block iterations\n\n', nrhs);

% Timing table
fprintf('TIMING:\n');
fprintf('%5s %7s %9s | %9s | %9s %6s %4s | %9s %5s %4s | %8s %8s\n', ...
    'Grid', 'Nodes', 'NNZ', 'mldivide', 'QMR', 'Iter', 'Flag', 'BLQMR', 'Iter', 'Flag', 'BL/mldiv', 'BL/QMR');
fprintf('%5s %7s %9s | %9s | %9s %6s %4s | %9s %5s %4s | %8s %8s\n', ...
    '-----', '-------', '---------', '---------', '---------', '------', '----', '---------', '-----', '----', '--------', '--------');

for i = 1:length(results)
    r = results(i);
    grid_str = sprintf('%d^3', r.grid);
    
    t_mld = format_time(r.t_mldivide);
    t_qmr = format_time(r.t_qmr);
    t_blq = format_time(r.t_blqmr);
    
    % Speedup vs mldivide
    if r.t_blqmr > 0 && r.flag_blqmr <= 1
        sp_mldiv = format_speedup(r.t_mldivide / r.t_blqmr);
    else
        sp_mldiv = 'N/A';
    end
    
    % Speedup vs QMR
    if r.t_blqmr > 0 && r.flag_blqmr <= 1 && r.flag_qmr <= 1
        sp_qmr = format_speedup(r.t_qmr / r.t_blqmr);
    else
        sp_qmr = 'N/A';
    end
    
    fprintf('%5s %7d %9d | %9s | %9s %6d %4d | %9s %5d %4d | %8s %8s\n', ...
        grid_str, r.n, r.nnz, t_mld, t_qmr, r.iter_qmr, r.flag_qmr, ...
        t_blq, r.iter_blqmr, r.flag_blqmr, sp_mldiv, sp_qmr);
end

% Residual table
fprintf('\nRESIDUAL ACCURACY (max over %d RHS):\n', nrhs);
fprintf('%5s %7s | %12s | %12s | %12s\n', 'Grid', 'Nodes', 'mldivide', 'QMR', 'BLQMR');
fprintf('%5s %7s | %12s | %12s | %12s\n', '-----', '-------', '------------', '------------', '------------');

for i = 1:length(results)
    r = results(i);
    grid_str = sprintf('%d^3', r.grid);
    res_mld = sprintf('%.2e', r.res_mldivide);
    
    if r.res_qmr < Inf
        res_qmr = sprintf('%.2e', r.res_qmr);
    else
        res_qmr = 'FAILED';
    end
    
    if r.res_blqmr < Inf
        res_blq = sprintf('%.2e', r.res_blqmr);
    else
        res_blq = 'FAILED';
    end
    fprintf('%5s %7d | %12s | %12s | %12s\n', grid_str, r.n, res_mld, res_qmr, res_blq);
end

% Iteration efficiency table
fprintf('\nITERATION COMPARISON (QMR total vs BLQMR block iterations):\n');
fprintf('%5s %7s | %8s | %8s | %8s | %10s\n', 'Grid', 'Nodes', 'QMR', 'BLQMR', 'Ratio', 'Ideal(1/%d)', nrhs);
fprintf('%5s %7s | %8s | %8s | %8s | %10s\n', '-----', '-------', '--------', '--------', '--------', '----------');

for i = 1:length(results)
    r = results(i);
    grid_str = sprintf('%d^3', r.grid);
    
    if r.flag_qmr <= 1 && r.flag_blqmr <= 1 && r.iter_qmr > 0
        ratio = r.iter_blqmr / r.iter_qmr;
        ratio_str = sprintf('%.3f', ratio);
    else
        ratio_str = 'N/A';
    end
    
    fprintf('%5s %7d | %8d | %8d | %8s | %10.3f\n', ...
        grid_str, r.n, r.iter_qmr, r.iter_blqmr, ratio_str, 1/nrhs);
end
end

function print_summary(real_results, complex_results)
%PRINT_SUMMARY Print overall summary statistics

fprintf('\n=====================================================================================================\n');
fprintf('SUMMARY\n');
fprintf('=====================================================================================================\n');

% Real matrices
converged_real_qmr = [real_results.flag_qmr] <= 1;
converged_real_blqmr = [real_results.flag_blqmr] == 0;

fprintf('\nREAL FEM matrices:\n');

if any(converged_real_qmr)
    speedups_qmr = [real_results(converged_real_qmr).t_mldivide] ./ [real_results(converged_real_qmr).t_qmr];
    fprintf('  QMR vs mldivide:   avg=%.2fx, min=%.2fx, max=%.2fx (%d/%d converged)\n', ...
        mean(speedups_qmr), min(speedups_qmr), max(speedups_qmr), sum(converged_real_qmr), length(real_results));
end

if any(converged_real_blqmr)
    speedups_blqmr = [real_results(converged_real_blqmr).t_mldivide] ./ [real_results(converged_real_blqmr).t_blqmr];
    fprintf('  BLQMR vs mldivide: avg=%.2fx, min=%.2fx, max=%.2fx (%d/%d converged)\n', ...
        mean(speedups_blqmr), min(speedups_blqmr), max(speedups_blqmr), sum(converged_real_blqmr), length(real_results));
    
    if any(converged_real_qmr & converged_real_blqmr)
        idx = converged_real_qmr & converged_real_blqmr;
        speedups_vs_qmr = [real_results(idx).t_qmr] ./ [real_results(idx).t_blqmr];
        fprintf('  BLQMR vs QMR:      avg=%.2fx, min=%.2fx, max=%.2fx\n', ...
            mean(speedups_vs_qmr), min(speedups_vs_qmr), max(speedups_vs_qmr));
    end
end

% Complex matrices
converged_complex_qmr = [complex_results.flag_qmr] <= 1;
converged_complex_blqmr = [complex_results.flag_blqmr] == 0;

fprintf('\nCOMPLEX FEM matrices:\n');

if any(converged_complex_qmr)
    speedups_qmr = [complex_results(converged_complex_qmr).t_mldivide] ./ [complex_results(converged_complex_qmr).t_qmr];
    fprintf('  QMR vs mldivide:   avg=%.2fx, min=%.2fx, max=%.2fx (%d/%d converged)\n', ...
        mean(speedups_qmr), min(speedups_qmr), max(speedups_qmr), sum(converged_complex_qmr), length(complex_results));
end

if any(converged_complex_blqmr)
    speedups_blqmr = [complex_results(converged_complex_blqmr).t_mldivide] ./ [complex_results(converged_complex_blqmr).t_blqmr];
    fprintf('  BLQMR vs mldivide: avg=%.2fx, min=%.2fx, max=%.2fx (%d/%d converged)\n', ...
        mean(speedups_blqmr), min(speedups_blqmr), max(speedups_blqmr), sum(converged_complex_blqmr), length(complex_results));
    
    if any(converged_complex_qmr & converged_complex_blqmr)
        idx = converged_complex_qmr & converged_complex_blqmr;
        speedups_vs_qmr = [complex_results(idx).t_qmr] ./ [complex_results(idx).t_blqmr];
        fprintf('  BLQMR vs QMR:      avg=%.2fx, min=%.2fx, max=%.2fx\n', ...
            mean(speedups_vs_qmr), min(speedups_vs_qmr), max(speedups_vs_qmr));
    end
end

fprintf('\n-----------------------------------------------------------------------------------------------------\n');
fprintf('Notes:\n');
fprintf('  - Mesh: tetrahedral grid from meshgrid6 (6 tets per cube)\n');
fprintf('  - Matrix: FEM stiffness + small mass (complex: +0.1i*mass for lossy media)\n');
fprintf('  - RHS: Point sources using barycentric coords, 4 nonzeros each\n');
fprintf('  - QMR: MATLAB built-in qmr(), solves each RHS separately (point method)\n');
fprintf('  - BLQMR: Block QMR, solves all RHS simultaneously (block method)\n');
fprintf('  - mldivide: auto-selects sparse solver (UMFPACK for LU)\n');
fprintf('  - Speedup > 1 means the method is faster than the reference\n');
fprintf('  - Iteration ratio < 1/%d indicates super-linear block acceleration\n', 4);
fprintf('=====================================================================================================\n');
end